# Bit Manipulation in Assembly

## Overview

This project demonstrates bit manipulation in RISC-V assembly. The purpose is to set or clear a specific bit in a given number based on an input flag. The repository contains two versions of the assembly code: one manually written and one generated by a toolchain from a C program.

## Manually Written Assembly Code

### Code Structure

1. **Loading Input Values:** The input number, bit position, and flag are loaded from memory into registers.
2. **Bit Mask Generation:** A mask is created by shifting 1 to the left by the bit position.
3. **Conditional Operations:** Depending on the flag value, the bit is either set (using OR) or cleared (using AND with an inverted mask).
4. **Exit Mechanism:** Includes a specific exit mechanism for the simulation environment, which may involve jumping to an infinite loop.

### Alignment and Segments

- **Data Section (`.data`):** Stores constants like `input_number`, `bit_position`, and `flag`.
- **Text Section (`.text`):** Contains the executable code. The manual code does not explicitly handle alignment.

## Toolchain-Generated Assembly Code

### Code Structure

1. **Function Definitions:** Defines separate functions for setting and clearing bits (`set_bit` and `clear_bit`).
2. **Stack Management:** Uses the stack to save and restore registers across function calls, ensuring that the calling function's state is preserved.
3. **Parameter Passing:** Parameters are passed via registers (`a0`, `a1`, etc.) and stack locations.
4. **Modular Approach:** The code is divided into functions with a clear entry (`main`), function calls, and exits.

### Alignment and Segments

- **Data Section (`.data`):** This section is not explicitly visible in the generated code but is handled internally by the toolchain.
- **Text Section (`.text`):** Contains the main function and additional functions (`set_bit` and `clear_bit`). The code is aligned to a 4-byte boundary for better performance.
- **Stack Alignment:** The generated code includes alignment directives (`.align 1` and stack adjustment), ensuring proper stack usage and function call conventions.
- **Special Sections:** Includes `.ident` for toolchain identification and `.size` for marking the size of functions.

### Flags and Attributes

- **Attributes:** 
  - `.attribute arch, "rv64i2p0_m2p0_a2p0_f2p0_d2p0_c2p0"` specifies the architecture and features supported by the generated code.
  - `.attribute unaligned_access, 0` indicates whether unaligned memory access is allowed (0 means disallowed).
  - `.attribute stack_align, 16` ensures stack alignment to a 16-byte boundary.

- **Stack and Function Management:**
  - The generated code uses `addi sp, sp, -32` and `sd` instructions to manage stack space and save/restore register values.
  - Functions are clearly defined with `.type` and `.size` directives, and register values are preserved across function calls.

## Differences

- **Code Modularity:** The manually written code is linear and lacks modularity, while the generated code is organized into separate functions, improving readability and maintainability.
- **Stack Usage:** The toolchain-generated code includes stack management, ensuring that function calls and local variables are handled properly, which is absent in the manually written code.
- **Alignment and Performance:** The generated code adheres to alignment requirements and includes additional sections and attributes for performance and toolchain compatibility.
- **Special Sections:** The generated code includes additional sections and directives like `.ident` and `.size`, which provide metadata about the code and ensure compatibility with toolchains and debugging tools.

## Conclusion

Both versions of the code perform bit manipulation operations but differ significantly in structure and details. The manually written code is simple and straightforward, while the toolchain-generated code is modular, adheres to standard conventions, and includes additional metadata and alignment considerations.

